{"posts":[{"title":"vcpkg初步尝试总结","text":"包管理器很好，使我的c++项目旋转 c++开发经常没用包管理器，集成第三方库简直痛苦,一个库可能要小一天准备整个小项目，看到目前出名的C++ 包管理器有vcpkg(后台微软，没有官方二进制包)和canon(有二进制包)。后面选了vcpkg，因为有微软后台。当年Gentoo的教训给得不够 集成vcpkg的方式是给cmake一个vcpkg提供的假的toolchain文件，它会在里面搞事，不确定这个决定怎么下的，不像是深思熟虑或有很好设计后的决定,给人的感觉是 让我试试看什么时机能集成进去 咦 这里可以，那就这里吧 因为后面的经历让我感觉这个时机不算合理，例如有个问题是编译环境不同步。不过，这也有可能是cmake没有官方支持包管理器的锅。 未用包管理器之前，想用一个开源第三方库 找到代码仓库 看懂是怎么编译的 尝试编译，解决编译错误 把编译出来的二进制入库，记录编译时的git sha1 生成cmake的可链接目标: 拷需要include的文件到合适的位置 设置各种属性：二进制路径、include目录、预定义宏、编译/链接参数…… 如果使用vcpkg 在一个json文件里面说我想用xxx这个库 cmake脚本里project后find_module(xxx MODULE) target_link_library(target xxx) 怎么快速理解vcpkg 执行时机：在cmake脚本执行project()之前，cmake设置编译工具链的时候 做了什么：下载/编译/提供第三方库的cmake目标给cmake 提供的cmake目标已经设置好各种INTERFACE属性，因此不需要自己加include，define之类的，直接一句link就够了 自带各第三方库的编译脚本，无须关注各种编译细节，并且可裁剪库功能 基本名词 port: 一个第三方软件是一个port feature：库的可选特性 triplet: 一个cmake文件，告诉vcpkg编译相关各种参数。有vcpkg内建支持，也有社区提供的。用文件名的basename作为名字 buildtree：vcpkg里所有第三方库的编译根目录 对于一个第三方库来说 用manifest.json来描述基本信息 用portfile.cmake等其他附属文件来告诉vcpkg怎么编译这个第三方软件 两种用法 classic模式: 各项目共享一个vcpkg的编译输出 manifest模式: 一个项目独享自己的vcpkg实例 较好实践 把vcpkg当子仓库，使用manifest模式：避免与其他项目冲突，例如同名库的不同版本、编译参数之类的问题 禁用库的默认feature：避免编入不必要的东西 与cmake preset搭配：一条龙的ci服务 其他 怎么自定义第三方库: 使用自己的portfile 怎么改动态/静态等各种编译参数: 用自己的triplet","link":"/2022/04/18/about-vcpkg/"}],"tags":[],"categories":[],"pages":[]}