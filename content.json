{"posts":[{"title":"vcpkg初步尝试总结","text":"包管理器很好，使我的c++项目旋转 c++开发经常没用包管理器，集成第三方库简直痛苦,一个库可能要小一天准备整个小项目，看到目前出名的C++ 包管理器有vcpkg(后台微软，没有官方二进制包)和canon(有二进制包)。后面选了vcpkg，因为有微软后台。当年Gentoo的教训给得不够 集成vcpkg的方式是给cmake一个vcpkg提供的假的toolchain文件，它会在里面搞事，不确定这个决定怎么下的，不像是深思熟虑或有很好设计后的决定,给人的感觉是 让我试试看什么时机能集成进去 咦 这里可以，那就这里吧 因为后面的经历让我感觉这个时机不算合理，例如有个问题是编译环境不同步。不过，这也有可能是cmake没有官方支持包管理器的锅。 未用包管理器之前，想用一个开源第三方库 找到代码仓库 看懂是怎么编译的 尝试编译，解决编译错误 把编译出来的二进制入库，记录编译时的git sha1 生成cmake的可链接目标: 拷需要include的文件到合适的位置 设置各种属性：二进制路径、include目录、预定义宏、编译/链接参数…… 如果使用vcpkg 在一个json文件里面说我想用xxx这个库 cmake脚本里project后find_module(xxx MODULE) target_link_library(target xxx) 怎么快速理解vcpkg 执行时机：在cmake脚本执行project()之前，cmake设置编译工具链的时候 做了什么：下载/编译/提供第三方库的cmake目标给cmake 提供的cmake目标已经设置好各种INTERFACE属性，因此不需要自己加include，define之类的，直接一句link就够了 自带各第三方库的编译脚本，无须关注各种编译细节，并且可裁剪库功能 基本名词 port: 一个第三方软件是一个port feature：库的可选特性 triplet: 一个cmake文件，告诉vcpkg编译相关各种参数。有vcpkg内建支持，也有社区提供的。用文件名的basename作为名字 buildtree：vcpkg里所有第三方库的编译根目录 对于一个第三方库来说 用manifest.json来描述基本信息 用portfile.cmake等其他附属文件来告诉vcpkg怎么编译这个第三方软件 两种用法 classic模式: 各项目共享一个vcpkg的编译输出 manifest模式: 一个项目独享自己的vcpkg实例 较好实践 把vcpkg当子仓库，使用manifest模式：避免与其他项目冲突，例如同名库的不同版本、编译参数之类的问题 禁用库的默认feature：避免编入不必要的东西 与cmake preset搭配：一条龙的ci服务 其他 怎么自定义第三方库: 使用自己的portfile 怎么改动态/静态等各种编译参数: 用自己的triplet","link":"/2022/04/18/about-vcpkg/"},{"title":"cmake与vcpkg共享编译环境和参数","text":"vcpkg很贴心地隔离了第三方库的编译环境：它的运行时机在cmake的project之前，此时cmake还没有检测编译环境，也就是说vcpkg是自己去找“喜欢”的编译环境，与cmake选择环境的逻辑不一定一致 但有时的确有共享的需求： 虽然理论上现在的msvc的各版本间都是二进制兼容的，但一般情况也希望他们选择了相同的编译器 有些优化参数也想传给第三方库，压榨一点🤏性能出来，例如LTCG神马的 开ASAN貌似需要大家都开了，不然启动就会寄（可能因为我是编的都是静态的） 同步编译器版本2024-02-28: 原bug说已经修复了，于是在本地升级vs，尝试装了多个版本编译器，发现bug其实还在，估计是因为虽然vs和高版本的编译器更新了，但低版本的没有更新。还发现cmake选哪个版本的msvc甚至跟安装顺序有关联，甚至能出现cmake指定14.39但用上14.38这种滑稽错误。累了，把ci停了，以后在本地跑吧，或者什么时候整个自己的runner 我的小project在github上，开了ci，用官方提供的windows-2022这个runner。之前就经常有编译器版本问题，都是用临时办法绕过，最近才算搞明白什么鬼情况。然后继续用临时办法绕过…… vcpkg找编译器：vswhere.exe执行一下，取所有版本里符合triplet指定的最新的，然后不告诉你它用了什么版本，除非使用--debug cmake找编译器：找CMakePresets.json指定的toolset版本，如&quot;v143,host=x64,version=14.37&quot;，然后：No CMAKE_CXX_COMPILER could be found. ??? 因为🌶🐔VS最近的版本有这个烂了半年的bug，导致cmake无法指定小版本号，一指定就找不到。指定大版本的情况下又只能找到同一个大版本(如v143)里的默认版本，而这个默认版本居然是低版本 在windows-2022这个runner上就是装了v143的多个版本，因此vcpkg和cmake会用上不同版本的编译器！ 临时解决办法：让vcpkg也用旧版本编译器经过一大堆翻找文档和踩坑：vcpkg使用并且仅使用triplet来确定第三方库的编译环境。所有的什么VCPKG_xx_CHAINLOAD_xx都是给宿主project用的，跟第三方库没有任何关系。 洁癖患者为了能在CMakePresets.json一个文件里控制两边的版本，最终使用了环境变量的办法 在CMakePresets.json里设置vcpkg启动时透穿给vcpkg的环境变量，如TL_PLATFORM_TOOLSET_VERSION，然后添加到VCPKG_KEEP_ENV_VARS CMakePresets.json1234&quot;environment&quot;: { &quot;TL_PLATFORM_TOOLSET_VERSION&quot;: &quot;14.37&quot;, &quot;VCPKG_KEEP_ENV_VARS&quot;: &quot;TL_PLATFORM_TOOLSET_VERSION&quot;} 在自己的triplet.cmake里设置给vcpkg 在triplet文件里设置vcpkg相关值的时候，只能用cmake变量（在CMakePresets.json里有些项要用cmake cache变量，有些要用环境变量，VCPKG疯了 不直接用VCPKG_开头的名字是为了避免混淆，因为它不是给vcpkg读的 triplet.cmake1234if (DEFINED ENV{TL_PLATFORM_TOOLSET_VERSION}) message(&quot;setting toolset version: $ENV{TL_PLATFORM_TOOLSET_VERSION}&quot;) set(VCPKG_PLATFORM_TOOLSET_VERSION $ENV{TL_PLATFORM_TOOLSET_VERSION})endif() 不确定vcpkg会不会因为编译器小版本变化而重编，所以把这个环境变量名字设置到ABI相关的环境变量里，之后变量值改了那么vcpkg会重编第三方库 1string(JOIN &quot;;&quot; VCPKG_ENV_PASSTHROUGH &quot;TL_PLATFORM_TOOLSET_VERSION&quot;) 完美解决办法：等vs修bug同步编译参数编译优化，我全都要 有些编译参数可以与库的不一致，如大部分优化参数。有些不行，例如/fsanitize=address，可能导致启动报错。强迫症患者为了避免一份编译参数要在项目cmake和triplet两边写的麻烦： 把需要共享的参数抽出来放到另一个cmake里，如build_opts.cmake 在triplet里include它：include(${CMAKE_CURRENT_LIST_DIR}/xxxx/build_opts.cmake) triplet里设置给vcpkg的VCPKG_*_FLAGS： 平时target_link_options要的是列表，vcpkg只认字符串，需要string(JOIN)一下 有_DEBUG或_RELEASE后缀的变量值最终会拼在无后缀的变量值上","link":"/2024/02/14/share-build-env-and-parameters-between-cmake-and-vcpkg/"},{"title":"试试全局pch","text":"pch使用方式 效果 不用pch 每个工程每个编译单元里的include都要编一次 工程里用自己的pch 每个工程里，放入pch里的include需要编一次 全局pch 整个project里，用到的同一个include都只需要编一次 如果各个工程编译选项都一致，那么可以用全局pch，减少编译时间 搜了下，cmake针对pch提供了REUSE_FROM功能 添加一个OBJECT类别的library target，例如叫gpch，让它生成.pch文件 告诉cmake要REUSE_FROM 123 target_precompile_headers(${_target} REUSE_FROM gpch) 目前三方库不多，于是把他们全塞进pch了，想法是 不放进gpch： 如果用了全局的pch，各个工程就不能弄自己的pch 所以就会变成每次用上第三方库的头文件都重复编 进gpch： 第三方库的编译参数也要汇集到gpch 所以就要把第三方库设置为gpch的公有/接口链接选项，其他所有工程直接链gpch。不然编pch时有这些定义但用pch时没有的话就出毛病了，编译器也会报错 但链接的时候会就总是会多出没用上的第三方库obj 我选择了放进去，毕竟链接器就是要干筛选的活儿，我相信它 最终喜闻乐见，编译debug从~14s下降到~10s，可喜可贺。目前还有报gpch的obj重复了的警告，一时没看出怎么解决，不过暂时不管它了","link":"/2023/06/08/try-global-pch/"},{"title":"C++ Modules 尝试","text":"TL;DR：让子弹再飞一会儿，等一个C++23折腾了两天，普通modules、header unit、standard library modules都折腾了下，到处翻文档、看blog，遇到编译器报错还好，能猜一下也能谷歌。遇到编译器崩溃就懵，只能一点点干掉代码排除 新版cmake支持尚未完全但勉强能用，vs虽然说自己支持了但还有不少的bug，如 遇上__try就报错 pch 与 modules 冲突导致编译器崩溃 其他一言不合就internal compiler error等等 C++20还没有能把标准库弄成module，因此在cppm里面要用上标准库的东西就要include，这又走回老路了，include多几个之后编译cppm就变得很慢 C++23的标准库module在msvc 14.36里面有了，但是还是experimental状态，开了之后能用import std;了，但也会开出些另外的bug 例如第三方库xx.h里有include &lt;vector&gt;, 那么使用这个库的时候，就不能import std;了，不然也是报错。msvc说不要include之后又import，那人家第三方库include了之后，所有用到这个库的module都不能import std;了？懵 最终用普通的module能编起来了，但编译变慢了：debug版本原本12-15s变成了18-20s。中途还注掉了不少三方库的代码才编过，担心接下来的开发会被module卡住，还是回滚了 接下来折腾全局PCH吧，感觉那个应该会让人愉悦","link":"/2023/06/07/trying-c++-modules/"},{"title":"想写一个c++应用框架","text":"在前司工作的时候，代码库很庞大，但组织起来总显凌乱，感觉没有很好地组织在一起。回想起来，大概是这样的感觉： 代码规模千万级 规模够大，因此在各个方向上，或多或少都会有那么1-N套框架、脚手架能用 一般是找个相对合适的改改，不行就再加个 加的时候没有明确的位置，只有相对合适的位置（指熟悉的目录 后面大概听说了一些其他开源项目的结构后，觉得原因应该是，规划上并没有一个非常明确的“基础框架”的层次，只要编译不出错，可能就“合适”。因此很多偏基础、通用的东西没有合适的位置，大家会把它们写在自己的模块里，需要相同功能的话就复制一份。 这个问题到了后来稍有改观，会有一些主力的框架了。但总感觉那股凝聚力还不够，大家在各个框架里加代码的时候没有边界感，因为这些框架的设计语言、定位本来就很可能没有任何地方有申明，它们发声的渠道只有编译错误。因此它们的实际层次会不会扩张与代码审查人的忙碌程度相关。 还有就是，有些烂问题一直存在，动是不能动的，解决它要动很多关键模块。例如，有个很关键的工程，应该有上千的cpp，其中有application的定义，在一个头文件里，很多接口可以从这里获得。这个头文件，放在了pch里面。随便动一下这个头文件，这个工程就要编十几分钟。当时年少无知的我，有把它从pch里拿出来的冲动。后来转念一想：如果大部分cpp都include了这个头文件，还真有可能放pch比不放pch更快。现在在想，当时为啥不试试看哪个快咧！ 我对自己的代码还是有执念的，会做好它们的定位和层次，有些通用的代码文件就尽量放到更高的层级，为以后重用打下基础。 所以我觉得，一定要有一个基础框架的概念： 这个框架内有多个小框架 小框架们有严格的层次，不可逾越 有这样的归属地后，代码的改进就起码是一直在合适的地方累积，不容易出现在这个框架修完的bug在另一个地方再修一遍 因此，偶尔就会有整个基础框架的冲动。现在想整个小项目，正是造轮子的好借口。 基于在前司的各种调dmp、开发经验，遐想了一下这个库的功能： 进程的概念 exe的路径、目录，忘掉GetModuleHandle吧 程序的数据目录 app的概念 用service来提供其他功能 非侵入式的，做到加功能不需要改动app 生命周期管理 全局变量管理 把全局变量的声明周期缩小到main函数里 dll管理 可以在任意线程load 在期望的线程提供初始化、反初始化时机：不用整全局变量了 消息循环 信号槽：解耦的观察者，挺香的 日志，不用再整什么OutputDebugString了 程序设置 命令行 配置文件 注册表 线程管理 谁启动的线程 线程名字（调试福音） 任务相关 任务分发、暂停、取消 线程池 暂停/继续/取消 cpu/io优先级 封装常用cmake功能 添加target一个调用就设置完所有东西，包括代码文件、链接目标等 添加资源也包好，不要老自己写add_custom_command了，感觉会折寿 自动化测试 单元测试 集成测试 随便想想就这么多了，激动，手也痒起来了，现在就开撸！！！","link":"/2023/04/19/want-to-write-a-c-app-framework/"}],"tags":[{"name":"cmake","slug":"cmake","link":"/tags/cmake/"},{"name":"vcpkg","slug":"vcpkg","link":"/tags/vcpkg/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"pch","slug":"pch","link":"/tags/pch/"},{"name":"modules","slug":"modules","link":"/tags/modules/"}],"categories":[{"name":"学习","slug":"学习","link":"/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"思考","slug":"思考","link":"/categories/%E6%80%9D%E8%80%83/"}],"pages":[]}