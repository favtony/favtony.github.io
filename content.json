{"posts":[{"title":"试试全局pch","text":"pch使用方式 效果 不用pch 每个工程每个编译单元里的include都要编一次 工程里用自己的pch 每个工程里，放入pch里的include需要编一次 全局pch 整个project里，用到的同一个include都只需要编一次 如果各个工程编译选项都一致，那么可以用全局pch，减少编译时间 搜了下，cmake针对pch提供了REUSE_FROM功能 添加一个OBJECT类别的library target，例如叫gpch，让它生成.pch文件 告诉cmake要REUSE_FROM 123 target_precompile_headers(${_target} REUSE_FROM gpch) 目前三方库不多，于是把他们全塞进pch了，想法是 不放进gpch： 如果用了全局的pch，各个工程就不能弄自己的pch 所以就会变成每次用上第三方库的头文件都重复编 进gpch： 第三方库的编译参数也要汇集到gpch 所以就要把第三方库设置为gpch的公有/接口链接选项，其他所有工程直接链gpch。不然编pch时有这些定义但用pch时没有的话就出毛病了，编译器也会报错 但链接的时候会就总是会多出没用上的第三方库obj 我选择了放进去，毕竟链接器就是要干筛选的活儿，我相信它 最终喜闻乐见，编译debug从14s下降到10s，可喜可贺。目前还有报gpch的obj重复了的警告，一时没看出怎么解决，不过暂时不管它了","link":"/2023/06/08/try-global-pch/"},{"title":"C++ Modules 尝试","text":"TL;DR：让子弹再飞一会儿，等一个C++23折腾了两天，普通modules、header unit、standard library modules都折腾了下，到处翻文档、看blog，遇到编译器报错还好，能猜一下也能谷歌。遇到编译器崩溃就懵，只能一点点干掉代码排除 新版cmake支持尚未完全但勉强能用，vs虽然说自己支持了但还有不少的bug，如 遇上__try就报错 pch 与 modules 冲突导致编译器崩溃 其他一言不合就internal compiler error等等 C++20还没有能把标准库弄成module，因此在cppm里面要用上标准库的东西就要include，这又走回老路了，include多几个之后编译cppm就变得很慢 C++23的标准库module在msvc 14.36里面有了，但是还是experimental状态，开了之后能用import std;了，但也会开出些另外的bug 例如第三方库xx.h里有include &lt;vector&gt;, 那么使用这个库的时候，就不能import std;了，不然也是报错。msvc说不要include之后又import，那人家第三方库include了之后，所有用到这个库的module都不能import std;了？懵 最终用普通的module能编起来了，但编译变慢了：debug版本原本12-15s变成了18-20s。中途还注掉了不少三方库的代码才编过，担心接下来的开发会被module卡住，还是回滚了 接下来折腾全局PCH吧，感觉那个应该会让人愉悦","link":"/2023/06/07/trying-c++-modules/"},{"title":"vcpkg初步尝试总结","text":"包管理器很好，使我的c++项目旋转 c++开发经常没用包管理器，集成第三方库简直痛苦,一个库可能要小一天准备整个小项目，看到目前出名的C++ 包管理器有vcpkg(后台微软，没有官方二进制包)和canon(有二进制包)。后面选了vcpkg，因为有微软后台。当年Gentoo的教训给得不够 集成vcpkg的方式是给cmake一个vcpkg提供的假的toolchain文件，它会在里面搞事，不确定这个决定怎么下的，不像是深思熟虑或有很好设计后的决定,给人的感觉是 让我试试看什么时机能集成进去 咦 这里可以，那就这里吧 因为后面的经历让我感觉这个时机不算合理，例如有个问题是编译环境不同步。不过，这也有可能是cmake没有官方支持包管理器的锅。 未用包管理器之前，想用一个开源第三方库 找到代码仓库 看懂是怎么编译的 尝试编译，解决编译错误 把编译出来的二进制入库，记录编译时的git sha1 生成cmake的可链接目标: 拷需要include的文件到合适的位置 设置各种属性：二进制路径、include目录、预定义宏、编译/链接参数…… 如果使用vcpkg 在一个json文件里面说我想用xxx这个库 cmake脚本里project后find_module(xxx MODULE) target_link_library(target xxx) 怎么快速理解vcpkg 执行时机：在cmake脚本执行project()之前，cmake设置编译工具链的时候 做了什么：下载/编译/提供第三方库的cmake目标给cmake 提供的cmake目标已经设置好各种INTERFACE属性，因此不需要自己加include，define之类的，直接一句link就够了 自带各第三方库的编译脚本，无须关注各种编译细节，并且可裁剪库功能 基本名词 port: 一个第三方软件是一个port feature：库的可选特性 triplet: 一个cmake文件，告诉vcpkg编译相关各种参数。有vcpkg内建支持，也有社区提供的。用文件名的basename作为名字 buildtree：vcpkg里所有第三方库的编译根目录 对于一个第三方库来说 用manifest.json来描述基本信息 用portfile.cmake等其他附属文件来告诉vcpkg怎么编译这个第三方软件 两种用法 classic模式: 各项目共享一个vcpkg的编译输出 manifest模式: 一个项目独享自己的vcpkg实例 较好实践 把vcpkg当子仓库，使用manifest模式：避免与其他项目冲突，例如同名库的不同版本、编译参数之类的问题 禁用库的默认feature：避免编入不必要的东西 与cmake preset搭配：一条龙的ci服务 其他 怎么自定义第三方库: 使用自己的portfile 怎么改动态/静态等各种编译参数: 用自己的triplet","link":"/2022/04/18/about-vcpkg/"},{"title":"想写一个c++应用框架","text":"在前司工作的时候，代码库很庞大，但组织起来总显凌乱，感觉没有很好地组织在一起。回想起来，大概是这样的感觉： 代码规模千万级 规模够大，因此在各个方向上，或多或少都会有那么几套框架、脚手架能用 一般是找个相对合适的改改，不行就再加个 加的时候没有明确的位置，只有相对合适的位置 后面大概听说了一些其他开源项目的结构后，觉得原因应该是，规划上并没有一个非常明确的“基础框架”的层次，只要编译不出错，可能就“合适”。因此很多偏基础、通用的东西没有合适的位置，大家会把它们写在自己的模块里，需要相同功能的话就复制一份。 这个问题到了后来稍有改观，会有一些主力的框架了。但总感觉那股凝聚力还不够，大家在各个框架里加代码的时候不一定很有边界感，因为这些框架的设计语言、定位本来就很可能没有任何地方有申明，它们发声的渠道只有编译错误。因此它们的实际定位可能会随着代码审查人的忙碌程度浮动 还有就是，有些烂问题一直存在，动是不能动的，解决它要动很多关键模块。 不过我还是有执念的，自己的代码会做好它们的定位和层次，有些通用的代码文件就尽量放到更高的层级，为以后重用打下基础。 因此，偶尔就会有整个基础框架的冲动。现在想整个小项目，正是造轮子的好借口。 遐想了一下，这个库的这些功能应该出厂自带 有进程、app的概念，有消息循环功能 app这个层次内，有service来提供其他功能，非侵入式的，做到加功能不需要改动app 有类信号槽的功能：解耦的观察者，挺香的 日志，不用再整什么OutputDebugString了 命令行解析、拼凑 还有些既要又要 封装常用cmake功能，不要老自己写add_custom_command了，感觉会折寿","link":"/2023/04/19/want-to-write-a-c-app-framework/"}],"tags":[],"categories":[],"pages":[]}